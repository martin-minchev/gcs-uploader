{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 971b8626eeb0868305ce","webpack:///./src/gcs.js","webpack:///./src/steamer.js"],"names":["RESUME_OFFSET","DONE","INPROGRESS","PAUSE","CANCEL","clearEventQueue","eventQueue","event","length","shift","Upload","size","contentType","steamer","sessionUri","onprogress","onerror","ondone","oncancel","onpause","self","state","_progress","_error","_done","_cancel","_pause","progress","offset","_onprogress","push","error","_onerror","done","_ondone","cancel","_oncancel","pause","_onpause","prototype","constructor","resume","doUpload","currentState","cb","uploadChunk","chunk","range","options","method","mode","headers","includes","Object","assign","body","data","fetch","then","response","status","rangeHeader","get","lastByteReceived","split","Error","parseInt","upload","retry","next","catch","setTimeout","run","file","chunkSize","Steamer","type","module","exports","DEFAULT_CHUNK_SIZE","filename","window","File","FileReader","reader","Promise","resolve","_offset","limit","blob","slice","reject","onloadend","target","readyState","loaded","result","readAsArrayBuffer"],"mappings":"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","file":"gcs-uploader.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"gcsUploader\"] = factory();\n\telse\n\t\troot[\"gcsUploader\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 971b8626eeb0868305ce\n **/","/**\n * This module implements the logic to perform resumable uploads to GCS\n * from a web browser.\n *\n * It makes use of the File and FileReader Web APIs and it requires a small\n * server piece able to request and provide resumable uploads session URIs.\n *\n * Usage:\n *\n * ```javascript\n * import gcsUploader from 'gcs-uploader';\n *\n * const upload = gcsUploader.run(file);\n * upload.onprogress: function(progress) {\n *   console.log('Sent', progress.sent);\n *   console.log('Pending', progress.pending);\n * };\n * upload.ondone: function(info) {\n *   console.log('File uploaded. Metadata', info);\n * };\n * upload.oncancel: function() {...};\n * upload.onpause: function() {...};\n * upload.onerror: function(error) {\n *   console.error(error);\n * }\n *\n * // upload.cancel();\n * // upload.pause();\n * // upload.resume();\n * ```\n */\n\n'use strict';\n\nimport Steamer from './steamer.js';\n\nconst RESUME_OFFSET = '*';\n\n/**\n * Upload states.\n */\nconst DONE = 'done';\nconst INPROGRESS = 'inprogress';\nconst PAUSE = 'pause';\nconst CANCEL = 'cancel';\n\nconst clearEventQueue = (eventQueue, event) => {\n  while (eventQueue.length) {\n    event(eventQueue.shift());\n  }\n};\n\n/**\n * Helper class to keep state information about a file upload.\n *\n * Every state update causes the trigger of an event related to the\n * state change. For example, updating `upload.progress` triggers\n * the `onprogress` callback.\n */\nfunction Upload(size, contentType, steamer, sessionUri) {\n  // We need to queue events triggered before the callbacks are set.\n  // Once a callback is set, we check the corresponding event queue\n  // and fire its events.\n  this.eventQueue = {\n    onprogress: [],\n    onerror: [],\n    ondone: [],\n    oncancel: [],\n    onpause: []\n  };\n\n  this.size = size;\n  this.contentType = contentType;\n  this.steamer = steamer;\n  this.sessionUri = sessionUri;\n\n  const self = this;\n  this.state = {\n    _progress: 0,\n    _error: null,\n    _done: false,\n    _cancel: false,\n    _pause: false,\n    set progress(offset) {\n      if (!offset || offset === RESUME_OFFSET) {\n        return;\n      }\n\n      const progress = offset;\n\n      if (!self._onprogress) {\n        self.eventQueue.onprogress.push(progress);\n        return;\n      }\n\n      this._progress = progress;\n      self._onprogress(progress);\n    },\n    set error(error) {\n      if (!self._onerror) {\n        self.eventQueue.onerror.push(error);\n        return;\n      }\n      this._error = error;\n      self._onerror(error);\n    },\n    set done(done) {\n      if (!done) {\n        return;\n      }\n\n      this._done = true;\n\n      if (!self._ondone) {\n        self.eventQueue.ondone[0] = true;\n        return;\n      }\n\n      self._ondone();\n    },\n    set cancel(cancel) {\n      if (!cancel) {\n        return;\n      }\n\n      this._cancel = cancel;\n\n      if (!self._oncancel) {\n        self.eventQueue.oncancel[0] = cancel;\n        return;\n      }\n\n      self._oncancel();\n    },\n    set pause(pause) {\n      this._pause = pause;\n\n      if (!self._onpause) {\n        self.eventQueue.onpause[0] = pause;\n        return;\n      }\n\n      if (!pause) {\n        return;\n      }\n\n      // We only trigger the onpause event when we go from\n      // inprogress to pause state.\n      self._onpause();\n    }\n  };\n}\n\nUpload.prototype = (function() {\n  return {\n    /**\n     * Create a Upload instance.\n     *\n     * @constructs Upload\n     *\n     * @param {number} size - Upload size.\n     * @param {string} contentType - Content Type of the file being uploaded.\n     */\n    constructor: Upload,\n    set progress(progress) {\n      this.state.progress = progress;\n    },\n\n    /**\n     * Upload error setter. Triggers the .onerror callback.\n     *\n     * @param {any} error - Error details.\n     */\n    set error(error) {\n      this.state.error = error;\n    },\n\n    /**\n     * Cancel an ongoing upload. Triggers the .oncancel callback.\n     */\n    cancel() {\n      this.state.cancel = true;\n    },\n\n    /**\n     * Sets the upload as done. Triggers the .ondone callback.\n     */\n    done() {\n      this.state.done = true;\n    },\n\n    /**\n     * Pauses the upload. Triggers the .onpause callback.\n     */\n    pause() {\n      this.state.pause = true;\n    },\n\n    /**\n     * Resumes a paused upload.\n     */\n    resume() {\n      this.state.pause = false;\n      doUpload(this, RESUME_OFFSET);\n    },\n\n    /**\n     * Current state getter. An upload can have three states:\n     * - INPROGRESS\n     * - PAUSE\n     * - CANCEL\n     * - DONE\n     */\n    get currentState() {\n      if (this.state._done) {\n        return DONE;\n      }\n\n      if (this.state._cancel) {\n        return CANCEL;\n      }\n\n      if (this.state._pause) {\n        return PAUSE;\n      }\n\n      return INPROGRESS;\n    },\n\n    /**\n     * onprogress callback setter.\n     *\n     * @param {function} cb - callback.\n     */\n    set onprogress(cb) {\n      this._onprogress = cb;\n      clearEventQueue(this.eventQueue.onprogress, cb);\n    },\n\n    /**\n     * onerror callback setter.\n     *\n     * @param {function} cb - callback.\n     */\n    set onerror(cb) {\n      this._onerror = cb;\n      clearEventQueue(this.eventQueue.onerror, cb);\n    },\n\n    /**\n     * ondone callback setter.\n     *\n     * @param {function} cb - callback.\n     */\n    set ondone(cb) {\n      this._ondone = cb;\n      clearEventQueue(this.eventQueue.ondone, cb);\n    },\n\n    /**\n     * oncancel callback setter.\n     *\n     * @param {function} cb - callback.\n     */\n    set oncancel(cb) {\n      this._oncancel = cb;\n      clearEventQueue(this.eventQueue.oncancel, cb);\n    },\n\n    /**\n     * onpause callback setter.\n     *\n     * @param {function} cb - callback.\n     */\n    set onpause(cb) {\n      this._onpause = cb;\n      clearEventQueue(this.eventQueue.onpause, cb);\n    }\n  };\n})();\n\nconst uploadChunk = (sessionUri, chunk, contentType, range) => {\n  let options = {\n    method: 'put',\n    mode: 'cors'\n  };\n\n  let headers = {\n    'Access-Control-Allow-Origin': '*'\n  };\n\n  if (!range.includes('*')) {\n    headers = Object.assign(headers, {\n      'Content-Length': chunk.size,\n      'Content-Type': contentType,\n      'Content-Range': range\n    });\n    options.body = chunk.data;\n  }\n\n  options.headers = headers;\n\n  return fetch(sessionUri, options).then(response => {\n    if (response.status === 200 || response.status == 201) {\n      // Upload completed!\n      return { done: true };\n    }\n\n    if (response.status === 308) {\n      // Chunk uploaded, but there is still pending data to send.\n      const rangeHeader = response.headers.get('Range');\n      const lastByteReceived = rangeHeader.split('-')[1];\n      if (!lastByteReceived) {\n        throw new Error(`Invalid 'Range' header received`);\n      }\n      return { offset: parseInt(lastByteReceived) }\n    }\n\n    // Something went wrong, the service is unavailable, so we need to stop\n    // for a bit and try to resume our upload.\n    return { offset: RESUME_OFFSET };\n  });\n};\n\nconst doUpload = (upload, offset, retry = 0) => {\n  upload.steamer\n    .next(offset)\n    .then(chunk => {\n      let range;\n\n      if (offset) {\n        if (offset === RESUME_OFFSET) {\n          // Request offset\n          range = `bytes *`;\n        }\n        else {\n          // Resume upload from offset\n          range = `bytes ${offset}-${offset + chunk.size -1}`;\n        }\n      }\n      else {\n        // Start upload from scratch\n        range = `bytes 0-${chunk.size - 1}`;\n      }\n\n      // Format range\n      range = `${range}/${upload.size}`;\n\n      return uploadChunk(upload.sessionUri, chunk, upload.contentType, range);\n    })\n    .then(response => {\n      if (upload.currentState !== INPROGRESS) {\n        return;\n      }\n\n      if (response.done) {\n        return upload.done();\n      }\n\n      if (response.offset) {\n        upload.progress = offset;\n        return doUpload(upload, response.offset);\n      }\n\n      throw new Error('Unexpected response');\n    })\n    .catch(error => {\n      upload.error = error;\n\n      if (upload.currentState === INPROGRESS && retry < 5) {\n        // Retry maximum 5 times, wait 5 seconds between retries\n\n        setTimeout(\n          () => {\n            doUpload(upload, RESUME_OFFSET, retry+1);\n          },\n          5000\n        );\n      }\n    })\n  ;\n};\n\n/**\n * Module entry point. It performs the core logic of the uploader. The basic\n * algorithm is:\n *\n * 1. Request a session URL to the GCS proxy server.\n * 2. Upload chunks of data to this session URL.\n * 2.1. If one of these chunks of data fails to upload, retry until it succeeds\n *      or state.cancel() is called.\n */\nconst run = (file, sessionUri, chunkSize) => {\n  if (!file) {\n    throw new Error('You need to provide a file to upload');\n  }\n\n  const steamer = new Steamer(file, chunkSize);\n  const upload = new Upload(file.size, file.type, steamer, sessionUri);\n\n  doUpload(upload, RESUME_OFFSET);\n\n  return upload;\n};\n\nmodule.exports = { run };\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/gcs.js\n **/","'use strict';\n\nconst Steamer = (() => {\n  const DEFAULT_CHUNK_SIZE = 256 * 1024 * 4 * 100; // 100 MB\n\n  /**\n   * Steamer is a helper class to ease the process of slicing a file in\n   * small chunks of data.\n   */\n  class Steamer {\n    /**\n     * Create a Steamer instance.\n     *\n     * @constructs Steamer\n     *\n     * @param {string} filename - File to be uploaded.\n     * @param {object} chunkSize - Number of bytes of each file chunk.\n     */\n    constructor(filename, chunkSize) {\n      if (!window.File || !window.FileReader) {\n        throw new Error('Unsupported File API');\n      }\n\n      if (!filename) {\n        throw new Error('Missing mandatory file name');\n      }\n\n      this.file = filename;\n      this.chunkSize = chunkSize || DEFAULT_CHUNK_SIZE;\n\n      this.reader = new FileReader();\n\n      this.progress = 0;\n\n      return this;\n    }\n\n    /**\n     * Get the next chunk of data.\n     *\n     * @param {number} offset - initial byte of the data chunk.\n     *\n     * @return Promise that resolves with an object containing the chunk of\n     * data and the number of bytes read.\n     */\n    next(offset) {\n      if (offset === '*') {\n        return Promise.resolve();\n      }\n      const _offset = offset || this.progress;\n      let limit = _offset + this.chunkSize;\n      limit = limit <= this.file.size ? limit : this.file.size;\n      const blob = this.file.slice(_offset, limit);\n      return new Promise((resolve, reject) => {\n        this.reader.onerror = reject;\n        this.reader.onloadend = event => {\n          if (!event.target.readyState == FileReader.DONE) {\n            return;\n          }\n          this.progress += event.loaded;\n          resolve({\n            data: event.target.result,\n            size: event.loaded\n          });\n        };\n        this.reader.readAsArrayBuffer(blob);\n      });\n    }\n  };\n\n  return Steamer;\n})();\n\nmodule.exports = Steamer;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/steamer.js\n **/"],"sourceRoot":""}