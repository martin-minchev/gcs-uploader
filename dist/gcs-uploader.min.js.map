{"version":3,"sources":["gcs-uploader.min.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","Upload","size","contentType","steamer","sessionUri","eventQueue","onprogress","onerror","ondone","oncancel","onpause","self","state","_progress","_error","_done","_cancel","_pause","progress","offset","RESUME_OFFSET","_onprogress","push","error","_onerror","done","_ondone","cancel","_oncancel","pause","_onpause","_steamer","_steamer2","DONE","INPROGRESS","PAUSE","CANCEL","clearEventQueue","event","length","shift","prototype","constructor","resume","doUpload","currentState","cb","uploadChunk","chunk","range","options","method","mode","headers","Access-Control-Allow-Origin","includes","Object","assign","Content-Length","Content-Type","Content-Range","body","data","fetch","then","response","status","rangeHeader","get","lastByteReceived","split","Error","parseInt","upload","retry","arguments","undefined","next","catch","setTimeout","run","file","chunkSize","type","_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","i","descriptor","enumerable","configurable","writable","defineProperty","key","protoProps","staticProps","Steamer","DEFAULT_CHUNK_SIZE","filename","window","File","FileReader","reader","value","_this","Promise","resolve","_offset","limit","blob","slice","reject","onloadend","readyState","result","readAsArrayBuffer"],"mappings":"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","file":"gcs-uploader.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"gcsUploader\"] = factory();\n\telse\n\t\troot[\"gcsUploader\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * This module implements the logic to perform resumable uploads to GCS\n\t * from a web browser.\n\t *\n\t * It makes use of the File and FileReader Web APIs and it requires a small\n\t * server piece able to request and provide resumable uploads session URIs.\n\t *\n\t * Usage:\n\t *\n\t * ```javascript\n\t * import gcsUploader from 'gcs-uploader';\n\t *\n\t * const upload = gcsUploader.run(file);\n\t * upload.onprogress: function(progress) {\n\t *   console.log('Sent', progress.sent);\n\t *   console.log('Pending', progress.pending);\n\t * };\n\t * upload.ondone: function(info) {\n\t *   console.log('File uploaded. Metadata', info);\n\t * };\n\t * upload.oncancel: function() {...};\n\t * upload.onpause: function() {...};\n\t * upload.onerror: function(error) {\n\t *   console.error(error);\n\t * }\n\t *\n\t * // upload.cancel();\n\t * // upload.pause();\n\t * // upload.resume();\n\t * ```\n\t */\n\t\n\t'use strict';\n\t\n\tvar _steamer = __webpack_require__(1);\n\t\n\tvar _steamer2 = _interopRequireDefault(_steamer);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar RESUME_OFFSET = '*';\n\t\n\t/**\n\t * Upload states.\n\t */\n\tvar DONE = 'done';\n\tvar INPROGRESS = 'inprogress';\n\tvar PAUSE = 'pause';\n\tvar CANCEL = 'cancel';\n\t\n\tvar clearEventQueue = function clearEventQueue(eventQueue, event) {\n\t  while (eventQueue.length) {\n\t    event(eventQueue.shift());\n\t  }\n\t};\n\t\n\t/**\n\t * Helper class to keep state information about a file upload.\n\t *\n\t * Every state update causes the trigger of an event related to the\n\t * state change. For example, updating `upload.progress` triggers\n\t * the `onprogress` callback.\n\t */\n\tfunction Upload(size, contentType, steamer, sessionUri) {\n\t  // We need to queue events triggered before the callbacks are set.\n\t  // Once a callback is set, we check the corresponding event queue\n\t  // and fire its events.\n\t  this.eventQueue = {\n\t    onprogress: [],\n\t    onerror: [],\n\t    ondone: [],\n\t    oncancel: [],\n\t    onpause: []\n\t  };\n\t\n\t  this.size = size;\n\t  this.contentType = contentType;\n\t  this.steamer = steamer;\n\t  this.sessionUri = sessionUri;\n\t\n\t  var self = this;\n\t  this.state = {\n\t    _progress: 0,\n\t    _error: null,\n\t    _done: false,\n\t    _cancel: false,\n\t    _pause: false,\n\t    set progress(offset) {\n\t      if (!offset || offset === RESUME_OFFSET) {\n\t        return;\n\t      }\n\t\n\t      var progress = offset;\n\t\n\t      if (!self._onprogress) {\n\t        self.eventQueue.onprogress.push(progress);\n\t        return;\n\t      }\n\t\n\t      this._progress = progress;\n\t      self._onprogress(progress);\n\t    },\n\t    set error(error) {\n\t      if (!self._onerror) {\n\t        self.eventQueue.onerror.push(error);\n\t        return;\n\t      }\n\t      this._error = error;\n\t      self._onerror(error);\n\t    },\n\t    set done(done) {\n\t      if (!done) {\n\t        return;\n\t      }\n\t\n\t      this._done = true;\n\t\n\t      if (!self._ondone) {\n\t        self.eventQueue.ondone[0] = true;\n\t        return;\n\t      }\n\t\n\t      self._ondone();\n\t    },\n\t    set cancel(cancel) {\n\t      if (!cancel) {\n\t        return;\n\t      }\n\t\n\t      this._cancel = cancel;\n\t\n\t      if (!self._oncancel) {\n\t        self.eventQueue.oncancel[0] = cancel;\n\t        return;\n\t      }\n\t\n\t      self._oncancel();\n\t    },\n\t    set pause(pause) {\n\t      this._pause = pause;\n\t\n\t      if (!self._onpause) {\n\t        self.eventQueue.onpause[0] = pause;\n\t        return;\n\t      }\n\t\n\t      if (!pause) {\n\t        return;\n\t      }\n\t\n\t      // We only trigger the onpause event when we go from\n\t      // inprogress to pause state.\n\t      self._onpause();\n\t    }\n\t  };\n\t}\n\t\n\tUpload.prototype = function () {\n\t  return {\n\t    /**\n\t     * Create a Upload instance.\n\t     *\n\t     * @constructs Upload\n\t     *\n\t     * @param {number} size - Upload size.\n\t     * @param {string} contentType - Content Type of the file being uploaded.\n\t     */\n\t    constructor: Upload,\n\t    set progress(progress) {\n\t      this.state.progress = progress;\n\t    },\n\t\n\t    /**\n\t     * Upload error setter. Triggers the .onerror callback.\n\t     *\n\t     * @param {any} error - Error details.\n\t     */\n\t    set error(error) {\n\t      this.state.error = error;\n\t    },\n\t\n\t    /**\n\t     * Cancel an ongoing upload. Triggers the .oncancel callback.\n\t     */\n\t    cancel: function cancel() {\n\t      this.state.cancel = true;\n\t    },\n\t\n\t\n\t    /**\n\t     * Sets the upload as done. Triggers the .ondone callback.\n\t     */\n\t    done: function done() {\n\t      this.state.done = true;\n\t    },\n\t\n\t\n\t    /**\n\t     * Pauses the upload. Triggers the .onpause callback.\n\t     */\n\t    pause: function pause() {\n\t      this.state.pause = true;\n\t    },\n\t\n\t\n\t    /**\n\t     * Resumes a paused upload.\n\t     */\n\t    resume: function resume() {\n\t      this.state.pause = false;\n\t      doUpload(this, RESUME_OFFSET);\n\t    },\n\t\n\t\n\t    /**\n\t     * Current state getter. An upload can have three states:\n\t     * - INPROGRESS\n\t     * - PAUSE\n\t     * - CANCEL\n\t     * - DONE\n\t     */\n\t    get currentState() {\n\t      if (this.state._done) {\n\t        return DONE;\n\t      }\n\t\n\t      if (this.state._cancel) {\n\t        return CANCEL;\n\t      }\n\t\n\t      if (this.state._pause) {\n\t        return PAUSE;\n\t      }\n\t\n\t      return INPROGRESS;\n\t    },\n\t\n\t    /**\n\t     * onprogress callback setter.\n\t     *\n\t     * @param {function} cb - callback.\n\t     */\n\t    set onprogress(cb) {\n\t      this._onprogress = cb;\n\t      clearEventQueue(this.eventQueue.onprogress, cb);\n\t    },\n\t\n\t    /**\n\t     * onerror callback setter.\n\t     *\n\t     * @param {function} cb - callback.\n\t     */\n\t    set onerror(cb) {\n\t      this._onerror = cb;\n\t      clearEventQueue(this.eventQueue.onerror, cb);\n\t    },\n\t\n\t    /**\n\t     * ondone callback setter.\n\t     *\n\t     * @param {function} cb - callback.\n\t     */\n\t    set ondone(cb) {\n\t      this._ondone = cb;\n\t      clearEventQueue(this.eventQueue.ondone, cb);\n\t    },\n\t\n\t    /**\n\t     * oncancel callback setter.\n\t     *\n\t     * @param {function} cb - callback.\n\t     */\n\t    set oncancel(cb) {\n\t      this._oncancel = cb;\n\t      clearEventQueue(this.eventQueue.oncancel, cb);\n\t    },\n\t\n\t    /**\n\t     * onpause callback setter.\n\t     *\n\t     * @param {function} cb - callback.\n\t     */\n\t    set onpause(cb) {\n\t      this._onpause = cb;\n\t      clearEventQueue(this.eventQueue.onpause, cb);\n\t    }\n\t  };\n\t}();\n\t\n\tvar uploadChunk = function uploadChunk(sessionUri, chunk, contentType, range) {\n\t  var options = {\n\t    method: 'put',\n\t    mode: 'cors'\n\t  };\n\t\n\t  var headers = {\n\t    'Access-Control-Allow-Origin': '*'\n\t  };\n\t\n\t  if (!range.includes('*')) {\n\t    headers = Object.assign(headers, {\n\t      'Content-Length': chunk.size,\n\t      'Content-Type': contentType,\n\t      'Content-Range': range\n\t    });\n\t    options.body = chunk.data;\n\t  }\n\t\n\t  options.headers = headers;\n\t\n\t  return fetch(sessionUri, options).then(function (response) {\n\t    if (response.status === 200 || response.status == 201) {\n\t      // Upload completed!\n\t      return { done: true };\n\t    }\n\t\n\t    if (response.status === 308) {\n\t      // Chunk uploaded, but there is still pending data to send.\n\t      var rangeHeader = response.headers.get('Range');\n\t      var lastByteReceived = rangeHeader.split('-')[1];\n\t      if (!lastByteReceived) {\n\t        throw new Error('Invalid \\'Range\\' header received');\n\t      }\n\t      return { offset: parseInt(lastByteReceived) };\n\t    }\n\t\n\t    // Something went wrong, the service is unavailable, so we need to stop\n\t    // for a bit and try to resume our upload.\n\t    return { offset: RESUME_OFFSET };\n\t  });\n\t};\n\t\n\tvar doUpload = function doUpload(upload, offset) {\n\t  var retry = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\t\n\t  upload.steamer.next(offset).then(function (chunk) {\n\t    var range = void 0;\n\t\n\t    if (offset) {\n\t      if (offset === RESUME_OFFSET) {\n\t        // Request offset\n\t        range = 'bytes *';\n\t      } else {\n\t        // Resume upload from offset\n\t        range = 'bytes ' + offset + '-' + (offset + chunk.size - 1);\n\t      }\n\t    } else {\n\t      // Start upload from scratch\n\t      range = 'bytes 0-' + (chunk.size - 1);\n\t    }\n\t\n\t    // Format range\n\t    range = range + '/' + upload.size;\n\t\n\t    return uploadChunk(upload.sessionUri, chunk, upload.contentType, range);\n\t  }).then(function (response) {\n\t    if (upload.currentState !== INPROGRESS) {\n\t      return;\n\t    }\n\t\n\t    if (response.done) {\n\t      return upload.done();\n\t    }\n\t\n\t    if (response.offset) {\n\t      upload.progress = offset;\n\t      return doUpload(upload, response.offset);\n\t    }\n\t\n\t    throw new Error('Unexpected response');\n\t  }).catch(function (error) {\n\t    upload.error = error;\n\t\n\t    if (upload.currentState === INPROGRESS && retry < 5) {\n\t      // Retry maximum 5 times, wait 5 seconds between retries\n\t\n\t      setTimeout(function () {\n\t        doUpload(upload, RESUME_OFFSET, retry + 1);\n\t      }, 5000);\n\t    }\n\t  });\n\t};\n\t\n\t/**\n\t * Module entry point. It performs the core logic of the uploader. The basic\n\t * algorithm is:\n\t *\n\t * 1. Request a session URL to the GCS proxy server.\n\t * 2. Upload chunks of data to this session URL.\n\t * 2.1. If one of these chunks of data fails to upload, retry until it succeeds\n\t *      or state.cancel() is called.\n\t */\n\tvar run = function run(file, sessionUri, chunkSize) {\n\t  if (!file) {\n\t    throw new Error('You need to provide a file to upload');\n\t  }\n\t\n\t  var steamer = new _steamer2.default(file, chunkSize);\n\t  var upload = new Upload(file.size, file.type, steamer, sessionUri);\n\t\n\t  doUpload(upload, RESUME_OFFSET);\n\t\n\t  return upload;\n\t};\n\t\n\tmodule.exports = { run: run };\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar Steamer = function () {\n\t  var DEFAULT_CHUNK_SIZE = 256 * 1024 * 4 * 100; // 100 MB\n\t\n\t  /**\n\t   * Steamer is a helper class to ease the process of slicing a file in\n\t   * small chunks of data.\n\t   */\n\t\n\t  var Steamer = function () {\n\t    /**\n\t     * Create a Steamer instance.\n\t     *\n\t     * @constructs Steamer\n\t     *\n\t     * @param {string} filename - File to be uploaded.\n\t     * @param {object} chunkSize - Number of bytes of each file chunk.\n\t     */\n\t    function Steamer(filename, chunkSize) {\n\t      _classCallCheck(this, Steamer);\n\t\n\t      if (!window.File || !window.FileReader) {\n\t        throw new Error('Unsupported File API');\n\t      }\n\t\n\t      if (!filename) {\n\t        throw new Error('Missing mandatory file name');\n\t      }\n\t\n\t      this.file = filename;\n\t      this.chunkSize = chunkSize || DEFAULT_CHUNK_SIZE;\n\t\n\t      this.reader = new FileReader();\n\t\n\t      this.progress = 0;\n\t\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Get the next chunk of data.\n\t     *\n\t     * @param {number} offset - initial byte of the data chunk.\n\t     *\n\t     * @return Promise that resolves with an object containing the chunk of\n\t     * data and the number of bytes read.\n\t     */\n\t\n\t\n\t    _createClass(Steamer, [{\n\t      key: 'next',\n\t      value: function next(offset) {\n\t        var _this = this;\n\t\n\t        if (offset === '*') {\n\t          return Promise.resolve();\n\t        }\n\t        var _offset = offset || this.progress;\n\t        var limit = _offset + this.chunkSize;\n\t        limit = limit <= this.file.size ? limit : this.file.size;\n\t        var blob = this.file.slice(_offset, limit);\n\t        return new Promise(function (resolve, reject) {\n\t          _this.reader.onerror = reject;\n\t          _this.reader.onloadend = function (event) {\n\t            if (!event.target.readyState == FileReader.DONE) {\n\t              return;\n\t            }\n\t            _this.progress += event.loaded;\n\t            resolve({\n\t              data: event.target.result,\n\t              size: event.loaded\n\t            });\n\t          };\n\t          _this.reader.readAsArrayBuffer(blob);\n\t        });\n\t      }\n\t    }]);\n\t\n\t    return Steamer;\n\t  }();\n\t\n\t  ;\n\t\n\t  return Steamer;\n\t}();\n\t\n\tmodule.exports = Steamer;\n\n/***/ }\n/******/ ])\n});\n;\n"],"sourceRoot":"/source/"}